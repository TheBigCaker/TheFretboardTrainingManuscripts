{"file_contents":{"Plan.md":{"content":"﻿FretboardManuscripts: A Technical Implementation Blueprint\nPart I: The \"Manuscript Method\" as Generative Algorithm\n1.1 Deconstruction of the Pedagogical Framework\nThe foundation of the FretboardManuscripts application is its unique pedagogical method, codified in the strategic analysis as the \"Manuscript Method\". This method is a three-phase learning loop designed to build comprehensive musicianship, moving from rote mechanics to conceptual understanding and finally to practical application. This \"Drill, Map, Apply\" sequence is the core business logic that must be encoded into the application's content-generation engine.   \n\nPhase 1 (Drill): Rote Technical Skill\n\nObjective: To build muscle memory, endurance, and precise synchronization between the fretting and picking hands at a set tempo.\n\nImplementation: This phase consists of highly repetitive, rhythmic patterns executed on single, isolated strings. The provided C Major tablature (0, 1, 0, 3, 1, 3, 1, 0, 3, 0, 1, 0, 3, 0, 3, 1) is a prime example of this technical drill, focusing purely on the physical execution of diatonic notes.   \n\nPhase 2 (Map): Conceptual Knowledge\n\nObjective: To cement the theoretical and spatial patterns of a scale onto the fretboard, teaching the musician the physical \"shape\" of the scale in a specific position.\n\nImplementation: This phase abruptly shifts from rhythmic repetition to systematic, positional mapping. The C Major example demonstrates this with a clear ascending scale run across all six strings (e.g., E-string: 0, 1, 3; A-string: 2, 3, 5).   \n\nPhase 3 (Apply): Practical Integration\n\nObjective: To integrate the technical skill from Phase 1 and the conceptual knowledge from Phase 2 into a fluid, musical context.\n\nImplementation: This phase presents short, non-repetitive melodic fragments that mimic real-world musical passages. It trains string skipping and cross-string accuracy, applying the newly mapped scale in a practical, melodic fashion.   \n\n1.2 Algorithmic Codification: The generateManuscript Function\nTo automate the creation of new content, this three-phase method will be codified as a master generateManuscript function. This function will serve as the central content engine, programmatically generating a complete \"Manuscript\" for any valid instrument-key-scale combination.\n\nTop-Level Pseudocode:\n\nJavaScript\nfunction generateManuscript(instrumentName, rootNote, scaleName) {\n    // 1. Get data models\n    const instrument = InstrumentDatabase.get(instrumentName); // See Part II\n    const scale = ScaleDatabase.get(rootNote, scaleName);      // See Part III\n\n    // 2. Select the correct polymorphic drill template\n    const drillTemplate = selectDrillTemplate(scale); // See 1.4\n\n    // 3. Generate data for each phase\n    const phase1_data = generateDrill(instrument, scale, drillTemplate);\n    const phase2_data = generateMap(instrument, scale);\n    const phase3_data = generateApplication(instrument, scale);\n\n    // 4. Return the complete, structured data package\n    return {\n        drill: phase1_data,\n        map: phase2_data,\n        apply: phase3_data\n    };\n}\n1.3 The \"Manuscript Method\" as a Polymorphic Framework\nA critical architectural requirement is that the \"Manuscript Method,\" particularly Phase 1, must be polymorphic. It is not a single, static algorithm. The strategic analysis itself demonstrates that the drill must adapt its template based on the structure of the scale being practiced.   \n\nThe 3-note pattern (0-1-3) used in the C Major 7-note diatonic scale  is explicitly identified as \"ill-suited\" for a 5-note pentatonic scale. For pentatonics, a new \"2-Note Drill\" template (e.g., 5-8) is required. Similarly, for \"exotic\" scales containing an augmented (3-fret) interval, such as G-Harmonic Minor, the drill must be adapted again to specifically isolate and train that \"exotic\" jump (e.g., 0-1-3 for D-Eb-F#).   \n\nTherefore, the generateManuscript function must first inspect the properties of the selected scale (e.g., 5-note, 7-note, contains augmented interval) and then dispatch the appropriate generative \"Drill\" template. This makes the system extensible for any future scale type.\n\n1.4 Defining Generative Drill Templates\nBased on this polymorphic requirement, the application will launch with three foundational drill templates:\n\nTemplate_A (Diatonic/7-Note): The 16-beat, 3-note pattern as defined in the C Major tablature. This template will be used for the Major scale, all 7 of its modes, and the Melodic and Harmonic Minor scales.   \n\nTemplate_B (Pentatonic/5-Note): A 16-beat, 2-note pattern as defined in the A-Minor Pentatonic analysis. This template will be used for Major Pentatonic, Minor Pentatonic, and Blues scales.   \n\nTemplate_C (Augmented/Exotic): A 16-beat pattern designed to isolate and repeat any interval of 3 semitones (WH) or more found in the scale's formula. This will be used for scales like Harmonic Minor, Phrygian Dominant, and Hungarian Gypsy to train the most challenging intervals.   \n\nPart II: Definitive Instrument Tuning Database\n2.1 Data Architecture for Instrument Definitions\nAll instrument data will be stored in a centralized, immutable JSON file or JavaScript module (instrumentDatabase.js). This data is the absolute prerequisite for all theory, rendering, and audio playback logic. The Tonal.js theory engine and Tone.js audio engine are entirely dependent on these precise MIDI values to function.   \n\nEach instrument object in this database will contain:\n\nid: A unique programmatic identifier (e.g., \"guitar_6\").\n\ndisplayName: A human-readable name (e.g., \"6-String Guitar\").\n\nstringCount: The number of strings (e.g., 6).\n\ndefaultTuningName: The key for the default tuning (e.g., \"Standard\").\n\ntunings: An object containing one or more tuning definitions.\n\nEach tuning definition will contain an array of string objects, ordered from highest pitch to lowest pitch (or as logically grouped by the instrument), with each object containing:\n\nname: The programmatic string name (e.g., \"E4\").\n\nmidi: The definitive open-string MIDI note number.\n\n2.2 Table 1 (Definitive): Instrument Tuning & MIDI Reference\nThe following table is the definitive, architect-defined data model for all instruments supported by the FretboardManuscripts application. It resolves all ambiguities from the foundational research and establishes the non-negotiable MIDI values that the application's engines will use for all calculations.\n\nInstrument\tTuning Name\tString Name\tTuning Note\tOpen String MIDI Note\tSource(s)\nGuitar (6-String)\tStandard\te4\tE4\t64\t\nB3\tB3\t59\t\nG3\tG3\t55\t\nD3\tD3\t50\t\nA2\tA2\t45\t\nE2\tE2\t40\t\nBass (4-String)\tStandard\tG2\tG2\t43\t\nD2\tD2\t38\t\nA1\tA1\t33\t\nE1\tE1\t28\t\nBass (5-String)\tStandard (Low B)\tG2\tG2\t43\t\nD2\tD2\t38\t\nA1\tA1\t33\t\nE1\tE1\t28\t\nB0\tB0\t23\t\nUkulele\tStandard (Re-entrant)\tA4\tA4\t69\t\nE4\tE4\t64\t\nC4\tC4\t60\t\nG4\tG4\t67\t\nMandolin\tStandard\tE5\tE5\t76\t\nA4\tA4\t69\t\nD4\tD4\t62\t\nG3\tG3\t55\t\nBanjo (5-String)\tStandard (Open G)\td4\tD4\t62\t\nB3\tB3\t59\t\nG3\tG3\t55\t\nD3\tD3\t50\t\ng4 (short)\tG4\t67\t\nBanjo (4-String Tenor)\tStandard (Jazz)\tA4\tA4\t69\t\nD4\tD4\t62\t\nG3\tG3\t55\t\nC3\tC3\t48\t\nBanjo (4-String Tenor)\tIrish\tE4\tE4\t64\t\nA3\tA3\t57\t\nD3\tD3\t50\t\nG2\tG2\t43\t\nIrish Bouzouki\tGDAE\tE4\tE4\t64\t\nA3\tA3\t57\t\nD3\tD3\t50\t\nG2\tG2\t43\t\nIrish Bouzouki\tGDAD\tD4\tD4\t62\t\nA3\tA3\t57\t\nD3\tD3\t50\t\nG2\tG2\t43\t\nMandocello\tStandard\tA3\tA3\t57\t\nD3\tD3\t50\t\nG2\tG2\t43\t\nC2\tC2\t36\t\nChapman Stick (10-Str)\tClassic (Architect-Std)\tM1 (Str 1)\tD5\t74\t\nM2 (Str 2)\tA4\t69\t\nM3 (Str 3)\tE4\t64\t\nM4 (Str 4)\tB3\t59\t\nM5 (Str 5)\tF#3\t54\t\nB5 (Str 6)\tC2\t36\t\nB4 (Str 7)\tG2\t43\t\nB3 (Str 8)\tD3\t50\t\nB2 (Str 9)\tA3\t57\t\nB1 (Str 10)\tE4\t64\t\n  \n2.3 Establishing a Definitive Chapman Stick Tuning Standard\nThe research for the Chapman Stick provides relative intervals (\"down a 4th\", \"up a 5th\") but lacks the absolute MIDI pitch values necessary for the application's theory and audio engines. An application cannot function with relative tunings; a concrete MIDI value must be assigned to each string.   \n\nFor the purposes of this application, a logical \"Architect-Standard\" tuning has been derived. This standard anchors the instrument's two \"sides\" at logical octave positions to create a balanced, usable range.\n\nBass Side (Strings 6-10): The lowest string is 'C', which is anchored at C2 (MIDI 36). The remaining strings are calculated as ascending 5ths from this anchor: C2 (36), G2 (43), D3 (50), A3 (57), and E4 (64).   \n\nMelody Side (Strings 1-5): The lowest-pitched string on this side is 'F#', which is anchored at F#3 (MIDI 54). The remaining strings are calculated as descending 4ths (which, in pitch, is an ascent) from this anchor: F#3 (54), B3 (59), E4 (64), A4 (69), and D5 (74).   \n\nThis \"Architect-Standard\" tuning is programmatically sound, musically logical, and directly derived from the research. It will serve as the internal standard for the FretboardManuscripts application.   \n\nPart III: Comprehensive Scale and Mode Library\n3.1 Tonal.js as the \"Single Source of Truth\" for Music Theory\nThe strategic requirement to expand the scale library to be \"more robust\" introduces a significant data-management challenge. Research into \"exotic\" scales reveals multiple, often-conflicting, definitions, formulas, and names (e.g., conflicting formulas for \"Romanian Minor\"  or \"Oriental\" scale ).   \n\nManually hardcoding these varied formulas into the application is fragile, error-prone, and creates a significant maintenance burden.\n\nTherefore, the application architecture will mandate that Tonal.js serves as the \"Single Source of Truth\" for all music theory. The Tonal.js library already includes a comprehensive \"Scale dictionary\". The application will not maintain its own separate library of scale formulas (e.g., W-H steps).   \n\nInstead, the application will only maintain a list of display names (for the UI) that map directly to the internal names used by the Tonal.js scale dictionary. When a user selects \"Byzantine\" from the UI, the application will internally call Tonal.Scale.get(\"double harmonic major\") to retrieve the notes and intervals. This approach makes the application robust, maintainable, and leverages the full, tested power of the core theory library, while simultaneously resolving all data-level contradictions in the research.   \n\n3.2 Table 2 (Definitive): Foundational Scales & Modes\nThis table defines the mapping between the user-facing UI (as proposed in the 3-Step Sequential Filter ) and the internal Tonal.js scale names for foundational scales.   \n\nUI Category\tDisplay Name\tTonal.js Name\tSource(s)\nCommon\tMajor\tmajor\t\nCommon\tNatural Minor\taeolian\t\nCommon\tMajor Pentatonic\tmajor pentatonic\t\nCommon\tMinor Pentatonic\tminor pentatonic\t\nCommon\tBlues\tblues\t\nModes\tIonian (Major)\tionian\t\nModes\tDorian\tdorian\t\nModes\tPhrygian\tphrygian\t\nModes\tLydian\tlydian\t\nModes\tMixolydian\tmixolydian\t\nModes\tAeolian (Minor)\taeolian\t\nModes\tLocrian\tlocrian\t\nMinor\tHarmonic Minor\tharmonic minor\t\nMinor\tMelodic Minor\tmelodic minor\t\n  \n3.3 Table 3 (Definitive): Exotic & Unique Scales\nThis table defines the mapping for the \"Exotic / Other\" UI category, synthesizing all strategic and supplemental research into a Tonal.js-compatible format.\n\nUI Category\tDisplay Name\tTonal.js Name\tResearch Source(s)\nExotic\tPhrygian Dominant\tphrygian dominant\t\nExotic\tByzantine\tdouble harmonic major\t\nExotic\tRomanian Minor\tromanian minor\t\nExotic\tHungarian Gypsy\thungarian minor\t\nSymmetrical\tWhole Tone\twhole tone\t\nSymmetrical\tDiminished (W-H)\tdiminished or whole half\t\nSymmetrical\tDiminished (H-W)\thalf whole\t\nMelodic Minor\tLydian Augmented\tlydian augmented\t\nMelodic Minor\tAltered Scale\taltered\t\nExotic\tArabian\tarabian\t\nExotic\tPersian\tpersian\t\nExotic\tOriental\toriental\t\nExotic\tPrometheus\tprometheus\t\nPentatonic\tHirajōshi\thirajoshi\t\nExotic\tNeapolitan Major\tneapolitan major\t\n  \nPart IV: Architecture of the Core \"Engines\" (The \"Holy Trinity\" Stack)\n4.1 The \"Brain, Voice, Hands\" Architectural Model\nThe recommended architecture for the FretboardManuscripts application is a \"Holy Trinity\" stack of three specialized, decoupled JavaScript libraries. This separation of concerns is the most critical architectural decision for ensuring the platform is modular, testable, and scalable.   \n\nThe three components are:\n\nTonal.js (The Brain): The \"source of truth\" for all music theory. It only deals in data abstractions (note names, intervals, MIDI numbers, scale formulas) and performs no audio or visual functions.   \n\nTone.js (The Voice): The audio scheduling and synthesis engine. It knows nothing about music theory (e.g., \"C Major\"). It only accepts a timed array of events (e.g., \"play 'C4' at 1.5s\") and handles high-precision Web Audio playback.   \n\nSVGuitar (The Hands): The visual rendering engine. It knows nothing about theory or audio. It only accepts a simple data structure of fret/string coordinates and draws a clean SVG diagram.   \n\nThe application's core \"business logic\" is simply the glue that fetches data from Tonal.js (The Brain) and formats it as needed for either Tone.js (The Voice) or SVGuitar (The Hands).\n\n4.2 Engine #1: The \"Theory Engine\" (Tonal.js) Implementation Blueprint\nPurpose: To handle all music theory calculations, from scale generation to fretboard mapping.\n\nKey Functions & Code Examples:\n\nGet Notes in a Scale: Used to populate all scale-based features.\n\nJavaScript\n// Tonal.js provides the notes for any key/scale combination\nconst notes = Tonal.Scale.get(\"C major\").notes;\n// Returns:\n   \n\nGet Chords in a Key: Used by the Circle of Fifths (Part V).\n\nJavaScript\n// Tonal.js provides the diatonic chords for a key\nconst chords = Tonal.Scale.get(\"G major\").chords;\n// Returns:\n   \n\nNote/MIDI Conversion: Used by the audio engine parser (Part VII) and fretboard mapper.\n\nJavaScript\n// Convert MIDI number to Note Name\nconst noteName = Tonal.Note.fromMidi(61); // Returns: \"Db4\"\n\n// Convert Note Name to MIDI number\nconst midi = Tonal.Note.midi(\"C4\"); // Returns: 60\n   \n\nCore Fretboard Mapping Algorithm (Pseudocode): This algorithm maps any scale onto any instrument's fretboard.\n\nJavaScript\n// 1. Get the scale's pitch classes (notes without octaves)\nconst scalePitchClasses = Tonal.Scale.get(\"C major\").notes;\n// Returns:\n\n// 2. Get the instrument tuning from our database (Part II)\nconst tuning = InstrumentDatabase.get(\"guitar_6\").tunings.standard;\n// Returns:\n\nconst fretboardMap =; // This will store the final note map\nconst NUM_FRETS = 15; // As defined in the original HTML \n\n// 3. Iterate over each string in the tuning\nfor (const string of tuning) { // e.g., { name: \"E2\", midi: 40 }\n    let stringNotes =;\n    // 4. Iterate over each fret for that string\n    for (let fret = 0; fret <= NUM_FRETS; fret++) {\n        // 5. Calculate the note at this (string, fret) position\n        const noteMidi = string.midi + fret;\n        const noteName = Tonal.Note.fromMidi(noteMidi);\n        const pitchClass = Tonal.Note.pitchClass(noteName); // e.g., \"C\"\n\n        // 6. If that note's pitch class is in our scale, store it\n        if (scalePitchClasses.includes(pitchClass)) {\n            stringNotes.push({ fret: fret, note: noteName });\n        }\n    }\n    fretboardMap.push({ stringName: string.name, notes: stringNotes });\n}\n// fretboardMap now contains all C-Major notes for all 6 strings\n   \n\n4.3 Engine #2: The \"Audio Engine\" (Tone.js) Implementation Blueprint\nPurpose: To handle high-precision, scheduled playback of the \"Manuscript\" tablature.   \n\nKey Functions & Code Examples:\n\nScheduling with Tone.Part: The Tone.Part object is the ideal component for this task. It accepts an array of objects, each containing a time and a value (which will be our note).   \n\nBrowser AudioContext Requirement: A critical, non-trivial requirement of all modern browsers is that audio playback must be initiated by a user gesture (e.g., a click). The Tone.start() function must be called from within a click event handler to \"unlock\" the Web Audio API.   \n\nDefinitive Playback Code:\n\nJavaScript\n// 1. Create a synth instance (can be done on page load)\nconst synth = new Tone.Synth().toDestination();\n\n// 2. 'playableEvents' is the array generated by our CSV parser (See Part VII)\n//    It looks like this:\n//    [ { time: 0, note: \"E2\", duration: \"16n\" },\n//      { time: 0.125, note: \"F2\", duration: \"16n\" },\n//      { time: 0.250, note: \"E2\", duration: \"16n\" },... ]\n\n/**\n * This function must be attached to a \"Play\" button's click event.\n * @param {Array} playableEvents - The array of note objects.\n */\nasync function playManuscript(playableEvents) {\n    // 3. Start the AudioContext on user click [37]\n    await Tone.start();\n    \n    // 4. Stop any previously playing transport\n    Tone.Transport.stop();\n    Tone.Transport.cancel();\n    \n    // 5. Create a new Tone.Part from our events [33]\n    const tabPart = new Tone.Part((time, event) => {\n        // This callback is triggered by the Transport for each event\n        synth.triggerAttackRelease(event.note, event.duration, time);\n    }, playableEvents);\n\n    // 6. Start the part at time 0 and begin the transport\n    tabPart.start(0);\n    Tone.Transport.start();\n}\n4.4 Engine #3: The \"Rendering Engine\" (SVGuitar) Implementation Blueprint\nPurpose: To dynamically render clean, scalable SVG chord diagrams for the Key & Harmony section.   \n\nKey Functions & Code Examples:\n\nAPI: SVGuitar provides a simple, chainable API for configuring and drawing a chord. The library is initialized with a CSS selector for a target <div> and then configured with data.   \n\nDefinitive Rendering Function:\n\nJavaScript\n/**\n * Renders a chord diagram in a specific HTML element.\n * @param {Object} chordData - A chord voicing object from chord_shapes.json (See Part VI).\n * @param {String} targetDivId - The CSS ID of the container, e.g., \"#chord-display\".\n */\nfunction renderChordDiagram(chordData, targetDivId) {\n    // 1. Get the target HTML element\n    const targetElement = document.querySelector(targetDivId);\n    if (!targetElement) {\n        console.error(\"SVGuitar Target Element not found:\", targetDivId);\n        return;\n    }\n\n    // 2. Clear the target div of any previous diagram\n    targetElement.innerHTML = \"\";\n\n    // 3. Initialize the SVGuitar chart in the target element \n    const chart = new SVGuitarChord(targetDivId);\n\n    // 4. Configure the chart with data and draw it \n    chart.chord({\n        frets: chordData.frets,      // e.g., [-1, 3, 2, 0, 1, 0]\n        fingers: chordData.fingers,  // e.g., [null, 3, 2, 0, 1, 0]\n        title: chordData.title       // e.g., \"C Major\"\n    })\n   .draw();\n}\nPart V: Feature Blueprint: The Interactive Key & Harmony Section\n5.1 Architecture of the Circle of Fifths Component\nThis feature is a primary tool for teaching harmony and chord relationships. It will consist of an interactive UI element (HTML/SVG) representing the Circle of Fifths, which acts as a master control for the \"Key\" section.   \n\nData Flow:\n\nUser-Click (Key): A user clicks on a key (e.g., \"G\") in the Circle of Fifths UI.\n\nEvent: An onClick_Key(\"G\") event is fired.\n\nHandler (Tonal.js): The event handler calls the Tonal.js \"Theory Engine\": const chords = Tonal.Scale.get(\"G major\").chords;.   \n\nTonal.js Response: The engine returns an array of diatonic chord names: ``.\n\nUI Population (Diatonic Chords): The \"Diatonic Chord Display\" UI  is dynamically populated by mapping this array to create seven clickable buttons (e.g., [G], [Am], ``, etc.).   \n\nUI Population (Progressions): Simultaneously, the \"Chord Progression Display\" is populated (see 5.2).\n\nUser-Click (Chord): The user then clicks one of the new diatonic chord buttons (e.g., [Am]).\n\nEvent: An onClick_Chord(\"Am\") event is fired.\n\nHandler (SVGuitar): This event is handled by the \"Dynamic Chord Library\" logic (detailed in Part VI), which retrieves the \"Am\" chord shape for the current instrument and passes it to the renderChordDiagram function.\n\n5.2 Chord Progression Library Implementation\nTo provide immediate, practical context, the \"Chord Progression Display\"  will be populated whenever a key is selected. This component will use a static library of common progressions, as defined in the strategic analysis , and render them relative to the selected key.   \n\nLogic (Pseudocode):\n\nJavaScript\n// 1. Static library of progressions (defined in a module)\nconst progressions = {\n    major:,\n    minor:\n};\n\n// 2. This function is called by the onClick_Key handler\nfunction displayProgressions(keyName) {\n    const displayUI = document.querySelector(\"#progression-display\");\n    displayUI.innerHTML = \"\"; // Clear old progressions\n    \n    // 3. Use Tonal.js to resolve Roman numerals to chord names\n    const romanNumerals = Tonal.RomanNumeral.fromContext(keyName);\n    \n    // 4. Get the \"major\" list\n    const majorProgressions = progressions.major;\n    \n    // 5. Map formulas to actual chord names\n    for (const prog of majorProgressions) {\n        // e.g., \"I-V-vi-IV\" -> [\"I\", \"V\", \"vi\", \"IV\"]\n        const numerals = prog.formula.split(\"-\");\n        \n        // e.g., [\"I\", \"V\", \"vi\", \"IV\"] -> (if key is \"G\")\n        const chordNames = numerals.map(romanNumerals).join(\" - \");\n        \n        // 6. Render to UI\n        displayUI.innerHTML += `<p><b>${prog.name}:</b> ${chordNames}</p>`;\n    }\n}\n// Example Output for key=\"G\":\n// <p><b>Axis Progression:</b> G - D - Em - C</p>\n// <p><b>Doo-Wop:</b> G - Em - C - D</p>\n// <p><b>Jazz (ii-V-I):</b> Am - D - G</p>\n// <p><b>Minor Feel:</b> Em - C - G - D</p>\nPart VI: Feature Blueprint: The Dynamic Chord Library\n6.1 Integrating the SVGuitar Engine\nThis feature's logic is the handler for the onClick_Chord(\"Am\") event originating from the Diatonic Chord Display (Part V). Its sole purpose is to look up the correct chord shape in the database and pass it to the \"Rendering Engine\" (Part 4.4).\n\nHandler Logic (Pseudocode):\n\nJavaScript\nfunction onClick_Chord(chordName) {\n    // 1. Get the globally selected instrument from application state\n    const currentInstrumentId = AppState.getCurrentInstrument(); // e.g., \"guitar_6\"\n    \n    // 2. Get the chord data from our database (See 6.3)\n    // This will retrieve an array of voicings\n    const voicings = ChordDatabase.get(currentInstrumentId, chordName);\n    \n    if (!voicings |\n\n| voicings.length === 0) {\n        // Display an error or \"chord not found\"\n        return;\n    }\n    \n    // 3. By default, render the first voicing in the array\n    const defaultVoicing = voicings;\n    \n    // 4. Call the rendering engine function from Part 4.4\n    renderChordDiagram(defaultVoicing, \"#chord-display\");\n    \n    // 5. Update UI to show voicing-cycler buttons (e.g., \"1 of 3\")\n    // if (voicings.length > 1) {... }\n}\n6.2 The chord_shapes.json Data Model Refactor\nThe initial strategic analysis proposed a simple key-value model for the chord database (e.g., \"Am\": {... }). This model is insufficient. The strategic requirement to include \"Advanced & Unique Chord Voicings\" (e.g., Drop 2, Rootless, Shell Voicings)  means that a single chord name (like \"Am\") must map to multiple distinct voicings (e.g., Am Open, Am Barre 5th Fret, Am Triad 2-3-4 strings).   \n\nThe original data model, which only allows one voicing per chord, is a critical design flaw that would prevent this scalability.\n\nTherefore, the data structure must be refactored to support an array of voicings for each chord. The UI will then be required to include simple < and > buttons, allowing the user to cycle through the available voicings for the selected chord.\n\n6.3 Definitive Data Model for chord_shapes.json\nThis data model supports multiple voicings per chord, barre chord notation, and all properties required by the SVGuitar rendering engine.   \n\nJSON\n{\n  \"guitar_6\": {\n    \"Cmaj\": [\n      {\n        \"name\": \"Open\",\n        \"frets\": [-1, 3, 2, 0, 1, 0],\n        \"fingers\": [null, 3, 2, 0, 1, 0],\n        \"barres\":,\n        \"title\": \"C Major (Open)\"\n      },\n      {\n        \"name\": \"A-Shape Barre (3rd Fret)\",\n        \"frets\": [-1, 3, 5, 5, 5, 3],\n        \"fingers\": [null, 1, 3, 4, 4, 1],\n        \"barres\":,\n        \"title\": \"C Major (A-Shape)\"\n      },\n      {\n        \"name\": \"E-Shape Barre (8th Fret)\",\n        \"frets\": ,\n        \"fingers\": ,\n        \"barres\":,\n        \"title\": \"C Major (E-Shape)\"\n      }\n    ],\n    \"Am\": [\n      {\n        \"name\": \"Open\",\n        \"frets\": [-1, 0, 2, 2, 1, 0],\n        \"fingers\": [null, 0, 2, 3, 1, 0],\n        \"barres\":,\n        \"title\": \"A minor (Open)\"\n      }\n    ]\n  },\n  \"ukulele\": {\n    \"Cmaj\":,\n        \"fingers\": ,\n        \"barres\":,\n        \"title\": \"C Major\"\n      }\n    ]\n  },\n  \"mandolin\": {\n    \"Cmaj\":,\n        \"fingers\": ,\n        \"barres\":,\n        \"title\": \"C Major\"\n      }\n    ]\n  }\n}\n6.4 Database Expansion: Advanced & Unique Chord Voicings\nThis new data structure will be populated with the advanced voicings requested in the strategic analysis. The database will be expanded to include:   \n\nTriad Voicings: Triads on different string sets (1-2-3, 2-3-4, 3-4-5, 4-5-6).\n\nJazz & Rootless Voicings:\n\nShell Voicings: Basic (Root, 3rd, 7th) shapes.\n\nDrop Voicings: Standard 4-note \"Drop 2\" and \"Drop 3\" shapes.\n\nRootless Voicings: 3- and 4-note chords (e.g., 3-5-7-9) that omit the root.\n\nQuartal Voicings: Chords built from stacking 4ths (e.g., E-A-D-G).\n\nExtended Harmony: Common, playable shapes for Maj9, min9, Dom13, etc.\n\nAltered Dominant Chords: Shapes for 7b9, 7#9, 7b5.\n\nPart VII: Feature Blueprint: The \"Manuscript\" Playback System\n7.1 The 3-Step Stack: Parse -> Translate -> Play\nThis section provides the definitive logic for the \"CSV to Audio\" challenge. It details the algorithm that converts the raw tablature data  into the playableEvents array required by the Tone.js audio engine.   \n\nParse: Read the raw CSV file  and iterate through its grid.   \n\nTranslate: For each cell containing a fret number, \"translate\" it into a musical event by: a. Calculating its exact time in seconds. b. Calculating its exact noteName using Tonal.js and the instrument tuning map.\n\nPlay: Pass the resulting array of event objects to the Tone.Part object for playback.\n\n7.2 The \"Magic Number\" and Parser Logic\nThe \"translation\" step is made possible by a \"magic number\" derived from the data's metadata.\n\nThe Tempo is 120 BPM (120 quarter-notes per minute).   \n\n120 BPM = 2 beats (quarter-notes) per second.\n\n1 quarter-note = 0.5 seconds.\n\nThe beats division is 4, meaning the \"beats\" in the CSV (1-16) are 16th notes.   \n\nTherefore, the time duration of one \"beat\" (one column in the CSV) is 0.5/4=0.125 seconds.\n\nThis 0.125s is the \"magic number\" (the TIME_PER_BEAT) that allows for a simple, fast parser.\n\nParser Algorithm (Pseudocode):\n\nJavaScript\n// 1. Get the tuning map from our database (Part II)\nconst tuning = InstrumentDatabase.get(\"guitar_6\").tunings.standard;\nconst tuningMap = {\n    \"e4\": 64, \"B3\": 59, \"G3\": 55, \"D3\": 50, \"A2\": 45, \"E2\": 40\n}; // A simple map for fast lookups\n\n// 2. Define the \"Magic Number\"\nconst TIME_PER_BEAT = 0.125; // 16th note at 120 BPM\nconst NOTE_DURATION = \"16n\";\n\n// 3. 'csvData' is the raw, parsed CSV grid \nfunction parseCsvToPlayableEvents(csvData, tuningMap) {\n    const playableEvents =;\n    \n    // 4. Iterate over each DATA block in the CSV\n    for (const dataBlock of csvData.blocks) {\n        // 5. Iterate over each COLUMN (beat) in the block\n        // 'colIndex' goes from 0 to 15\n        for (let colIndex = 0; colIndex < dataBlock.beats.length; colIndex++) {\n            const beatNumber = dataBlock.startBeat + colIndex; // e.g., 17 + 0 = 17\n            \n            // 6. Iterate over each ROW (string) in that column\n            // 'stringName' e.g., \"e4\", \"B3\", \"G3\", \"D3\", \"A2\", \"E2\"\n            for (const stringName of dataBlock.strings) {\n                \n                // 7. Get the fret value from the cell\n                const fret = dataBlock.getValue(stringName, colIndex); // e.g., \"3\" or \"\"\n                \n                if (fret!== null && fret!== \"\") {\n                    // 8. A note was found! Translate it.\n                    // a. Calculate time\n                    const time = (beatNumber - 1) * TIME_PER_BEAT;\n                    \n                    // b. Calculate note name\n                    const baseMidi = tuningMap[stringName];\n                    const noteMidi = baseMidi + parseInt(fret, 10);\n                    const noteName = Tonal.Note.fromMidi(noteMidi); // [28]\n                    \n                    // 9. Add the event object to our array\n                    playableEvents.push({\n                        time: time,\n                        note: noteName,\n                        duration: NOTE_DURATION\n                    });\n                }\n            }\n        }\n    }\n    return playableEvents; // This array is ready for Tone.Part\n}\n7.3 UI Integration\nThe \"Play\" button for each \"Manuscript\" will be wired to the playManuscript(events) function (from Part 4.3), which will be fed the playableEvents array generated by this parser. A \"Stop\" button must also be provided, which simply calls Tone.Transport.stop() and tabPart.stop() (or its equivalent) to halt playback.\n\nPart VIII: UI/UX and Pedagogical Support\n8.1 Implementing the 3-Step Sequential Filter\nThe strategic analysis calls for a \"robust\" scale selection framework to replace the simple dropdowns in the existing HTML file. This will be implemented as a 3-Step Sequential Filter:   \n\nStep 1: Select Instrument (Global Context): An icon-based menu (Guitar, Bass, Ukulele, etc.) that globally sets the currentInstrument state. This selection will determine the fretboard diagrams, tunings, and chord_shapes.json file to be used.\n\nStep 2: Select Key (Tonic): A 12-button component (C, C#/Db, D, etc.) that sets the rootNote state.\n\nStep 3: Select Scale (Categorized Filter): The \"chunked\" menu system. This UI will be populated directly from the definitive scale tables (Table 2 and Table 3) in Part III. This ensures all menu items are valid and have a corresponding Tonal.js entry.   \n\nThe \"Generate Fretboard\" button  will then trigger the generateManuscript(currentInstrument, rootNote, selectedScale) function (from Part 1.2).   \n\n8.2 Implementing the \"Accordion\" Fundamentals Library\nTo help players \"understand the fundamentals,\" brief, expandable explanations will be integrated directly into the UI using \"Accordion\" or \"Collapsible\" panels. The content for these panels is provided in the strategic analysis  and will be placed contextually:   \n\n[+] What is a Fretboard Diagram? -> Placed near the main training interface.\n\n[+] What is a Scale? -> Placed inside the \"Select Scale\" UI (Step 3).\n\n[+] What are the Minor Scales? -> Placed inside the \"Select Scale\" UI, near the minor scale options.\n\n[+] What is a Chord and a Triad? -> Placed directly beneath the Circle of Fifths component (Part V).\n\n8.3 Re-using Existing CSS from TFTM.HTML\nThe existing HTML file TFTM.HTML  is not obsolete; it provides a valuable, pre-built CSS library for fretboard visualization. This library includes:   \n\nConstants: FRET_SPACING (75px) and STRING_PITCH_GAP (40px).\n\nCSS Classes: A complete system for styling notes, including .fret-dot, .fret-dot.root (for the tonic), .fret-dot.scale (for other scale notes), and .fret-dot.rest (for non-scale notes).\n\nThe new logic engines (the Fretboard Mapping Algorithm in Part 4.2 and the generateManuscript function in Part 1.2) will be written to output HTML that uses these existing CSS classes. This will save significant development time by hooking the new, powerful logic engines directly into the existing, styled \"view\" layer, fulfilling the strategic vision without redundant work.\n\nPart IX: Full Application Setup and Distribution Roadmap\n9.1 Development Environment Setup: Vite\nThe project will use Vite as its build tool, not Webpack. This is a definitive architectural choice for a new project in 2025.\n\nJustification (Vite vs. Webpack):\n\nThe Problem: Traditional bundlers (Webpack) suffer from a significant performance bottleneck. They must crawl and bundle the entire application before a development server can even start. As a project grows, this \"cold start\" time can extend to minutes. Furthermore, Hot Module Replacement (HMR) speed degrades linearly with the size of the application.   \n\nVite's Solution (Speed): Vite eliminates this bottleneck by not bundling during development.\n\nNative ESM: It serves application source code directly to the browser via native ES Modules (ESM). The browser only requests the files it needs, on-demand.   \n\nesbuild Pre-Bundling: Large, non-changing dependencies (like Tone.js or Tonal.js) are pre-bundled once using esbuild, a Go-based bundler that is 10-100x faster than JavaScript-based bundlers.   \n\nVite's Solution (HMR): Hot Module Replacement is \"near-instant\"  because when a file is changed, Vite only needs to invalidate that single module, not rebuild a large bundle graph.   \n\nFor a modern frontend application, Vite provides a \"hands-down\" superior developer experience, speed, and simplicity.   \n\n9.2 Production Bundling\nWhen the application is ready for deployment, the developer will run a single command: vite build    \n\nThis command will trigger Vite's production build process, which uses Rollup under the hood. This process will:   \n\nBundle: Combine all application JavaScript modules into highly optimized chunks.\n\nMinify: Remove all unnecessary characters (whitespace, comments) from JavaScript and CSS files to reduce their size.   \n\nTree-Shake: Automatically analyze the code and remove any \"dead code\" (functions, modules) that are not being used in the final application.   \n\nThe output of this command is a single /dist folder. This folder contains all the optimized, static HTML, CSS, and JS files that constitute the entire production-ready application.\n\n9.3 Distribution & CI/CD: The \"Zero-Config\" Workflow\nThe \"distribution\" of this static application will be a one-time, fully automated setup using a modern static hosting platform like Vercel or Netlify. These platforms are not just hosts; they are Git-based Continuous Integration / Continuous Deployment (CI/CD) pipelines.   \n\nThe entire deployment process is as follows:\n\nStep 1: The developer pushes the entire project source code (including package.json and vite.config.js) to a new GitHub, GitLab, or Bitbucket repository.\n\nStep 2: The developer logs into the Vercel or Netlify dashboard and selects \"Import Project\" or \"Add New Site\".   \n\nStep 3: The developer selects the new GitHub repository and authorizes the platform.\n\nStep 4: The platform auto-detects that this is a Vite project. It automatically sets the Build Command to vite build and the Publish Directory to dist. No manual configuration is needed.   \n\nStep 5: The developer clicks \"Deploy.\"\n\nThe site is now live. From this point forward, every time a developer runs git push to the main branch, the Vercel/Netlify platform will automatically pull the new code, run the vite build command in a secure cloud environment, and deploy the resulting /dist folder to its global CDN. This \"zero-config\" CI/CD workflow fully automates the distribution of the application.\n\nPart X: Conclusion and Strategic Summary\nThis technical blueprint provides the complete architectural and implementation plan for transforming FretboardManuscripts.com from a single-page tool into a scalable, data-driven pedagogical platform. The strategy is built upon four key pillars:\n\nA Decoupled \"Holy Trinity\" Architecture: By separating concerns into a \"Brain\" (Tonal.js), \"Voice\" (Tone.js), and \"Hands\" (SVGuitar), the application becomes modular, testable, and capable of handling future expansion with minimal friction.\n\nA Polymorphic Pedagogical Engine: The \"Manuscript Method\" (Drill, Map, Apply) is codified not as a static algorithm, but as a flexible, polymorphic framework capable of generating adaptive training drills for any type of musical scale.\n\nData-Driven, Centralized Logic: The application's stability is secured by centralizing all core data. A definitive InstrumentDatabase (Table 1) provides the immutable MIDI map for all audio and theory, while a ScaleDatabase (Tables 2 & 3) leverages Tonal.js as a \"Single Source of Truth\" for all music theory, resolving external data conflicts.\n\nA Modern Development & Distribution Pipeline: By adopting Vite for development  and a Git-based CI/CD workflow for distribution , the project ensures a fast, modern developer experience and a robust, automated deployment-to-production process.   \n\nThis blueprint, when executed, will deliver the robust, scalable, and \"intimate\" learning tool envisioned in the original strategic analysis.   \n\nr each \"Manuscript\" will be wired to the playManuscript(events) function (from Part 4.3), which will be fed the playableEvents array generated by this parser. A \"Stop\" button must also be provided, which simply calls Tone.Transport.stop() and tabPart.stop() (or its equivalent) to halt playback.Part VIII: UI/UX and Pedagogical Support8.1 Implementing the 3-Step Sequential FilterThe strategic analysis calls for a \"robust\" scale selection framework to replace the simple dropdowns in the existing HTML file.1 This will be implemented as a 3-Step Sequential Filter:Step 1: Select Instrument (Global Context): An icon-based menu (Guitar, Bass, Ukulele, etc.) that globally sets the currentInstrument state. This selection will determine the fretboard diagrams, tunings, and chord_shapes.json file to be used.Step 2: Select Key (Tonic): A 12-button component (C, C#/Db, D, etc.) that sets the rootNote state.Step 3: Select Scale (Categorized Filter): The \"chunked\" menu system.1 This UI will be populated directly from the definitive scale tables (Table 2 and Table 3) in Part III. This ensures all menu items are valid and have a corresponding Tonal.js entry.The \"Generate Fretboard\" button 2 will then trigger the generateManuscript(currentInstrument, rootNote, selectedScale) function (from Part 1.2).8.2 Implementing the \"Accordion\" Fundamentals LibraryTo help players \"understand the fundamentals,\" brief, expandable explanations will be integrated directly into the UI using \"Accordion\" or \"Collapsible\" panels.1 The content for these panels is provided in the strategic analysis 1 and will be placed contextually:[+] What is a Fretboard Diagram? -> Placed near the main training interface.[+] What is a Scale? -> Placed inside the \"Select Scale\" UI (Step 3).[+] What are the Minor Scales? -> Placed inside the \"Select Scale\" UI, near the minor scale options.[+] What is a Chord and a Triad? -> Placed directly beneath the Circle of Fifths component (Part V).8.3 Re-using Existing CSS from TFTM.HTMLThe existing HTML file TFTM.HTML 2 is not obsolete; it provides a valuable, pre-built CSS library for fretboard visualization. This library includes:Constants: FRET_SPACING (75px) and STRING_PITCH_GAP (40px).CSS Classes: A complete system for styling notes, including .fret-dot, .fret-dot.root (for the tonic), .fret-dot.scale (for other scale notes), and .fret-dot.rest (for non-scale notes).The new logic engines (the Fretboard Mapping Algorithm in Part 4.2 and the generateManuscript function in Part 1.2) will be written to output HTML that uses these existing CSS classes. This will save significant development time by hooking the new, powerful logic engines directly into the existing, styled \"view\" layer, fulfilling the strategic vision without redundant work.Part IX: Full Application Setup and Distribution Roadmap9.1 Development Environment Setup: ViteThe project will use Vite as its build tool, not Webpack. This is a definitive architectural choice for a new project in 2025.Justification (Vite vs. Webpack):The Problem: Traditional bundlers (Webpack) suffer from a significant performance bottleneck. They must crawl and bundle the entire application before a development server can even start. As a project grows, this \"cold start\" time can extend to minutes. Furthermore, Hot Module Replacement (HMR) speed degrades linearly with the size of the application.39Vite's Solution (Speed): Vite eliminates this bottleneck by not bundling during development.Native ESM: It serves application source code directly to the browser via native ES Modules (ESM). The browser only requests the files it needs, on-demand.40esbuild Pre-Bundling: Large, non-changing dependencies (like Tone.js or Tonal.js) are pre-bundled once using esbuild, a Go-based bundler that is 10-100x faster than JavaScript-based bundlers.40Vite's Solution (HMR): Hot Module Replacement is \"near-instant\" 41 because when a file is changed, Vite only needs to invalidate that single module, not rebuild a large bundle graph.39For a modern frontend application, Vite provides a \"hands-down\" superior developer experience, speed, and simplicity.439.2 Production BundlingWhen the application is ready for deployment, the developer will run a single command:vite build 45This command will trigger Vite's production build process, which uses Rollup under the hood.46 This process will:Bundle: Combine all application JavaScript modules into highly optimized chunks.Minify: Remove all unnecessary characters (whitespace, comments) from JavaScript and CSS files to reduce their size.47Tree-Shake: Automatically analyze the code and remove any \"dead code\" (functions, modules) that are not being used in the final application.48The output of this command is a single /dist folder. This folder contains all the optimized, static HTML, CSS, and JS files that constitute the entire production-ready application.9.3 Distribution & CI/CD: The \"Zero-Config\" WorkflowThe \"distribution\" of this static application will be a one-time, fully automated setup using a modern static hosting platform like Vercel or Netlify. These platforms are not just hosts; they are Git-based Continuous Integration / Continuous Deployment (CI/CD) pipelines.50The entire deployment process is as follows:Step 1: The developer pushes the entire project source code (including package.json and vite.config.js) to a new GitHub, GitLab, or Bitbucket repository.Step 2: The developer logs into the Vercel or Netlify dashboard and selects \"Import Project\" or \"Add New Site\".52Step 3: The developer selects the new GitHub repository and authorizes the platform.Step 4: The platform auto-detects that this is a Vite project.53 It automatically sets the Build Command to vite build and the Publish Directory to dist. No manual configuration is needed.52Step 5: The developer clicks \"Deploy.\"The site is now live. From this point forward, every time a developer runs git push to the main branch, the Vercel/Netlify platform will automatically pull the new code, run the vite build command in a secure cloud environment, and deploy the resulting /dist folder to its global CDN. This \"zero-config\" CI/CD workflow fully automates the distribution of the application.Part X: Conclusion and Strategic SummaryThis technical blueprint provides the complete architectural and implementation plan for transforming FretboardManuscripts.com from a single-page tool into a scalable, data-driven pedagogical platform. The strategy is built upon four key pillars:A Decoupled \"Holy Trinity\" Architecture: By separating concerns into a \"Brain\" (Tonal.js), \"Voice\" (Tone.js), and \"Hands\" (SVGuitar), the application becomes modular, testable, and capable of handling future expansion with minimal friction.A Polymorphic Pedagogical Engine: The \"Manuscript Method\" (Drill, Map, Apply) is codified not as a static algorithm, but as a flexible, polymorphic framework capable of generating adaptive training drills for any type of musical scale.Data-Driven, Centralized Logic: The application's stability is secured by centralizing all core data. A definitive InstrumentDatabase (Table 1) provides the immutable MIDI map for all audio and theory, while a ScaleDatabase (Tables 2 & 3) leverages Tonal.js as a \"Single Source of Truth\" for all music theory, resolving external data conflicts.A Modern Development & Distribution Pipeline: By adopting Vite for development 40 and a Git-based CI/CD workflow for distribution 52, the project ensures a fast, modern developer experience and a robust, automated deployment-to-production process.This blueprint, when executed, will deliver the robust, scalable, and \"intimate\" learning tool envisioned in the original strategic analysis.1","size_bytes":44121},"database.js":{"content":"// Part II: Definitive Instrument Tuning Database\n// This will be expanded with MIDI values and more instruments as per the blueprint.\nexport const TUNINGS = {\n    'guitar_6': {\n        name: '6-String Guitar (EADGBe)',\n        tuning: [\n            { string: 1, note_index: 4, octave: 4, thickness: 1, open_note: \"E4\", label: \"e\" },\n            { string: 2, note_index: 11, octave: 3, thickness: 2, open_note: \"B3\", label: \"B\" },\n            { string: 3, note_index: 7, octave: 3, thickness: 3, open_note: \"G3\", label: \"G\" },\n            { string: 4, note_index: 2, octave: 3, thickness: 4, open_note: \"D3\", label: \"D\" },\n            { string: 5, note_index: 9, octave: 2, thickness: 5, open_note: \"A2\", label: \"A\" },\n            { string: 6, note_index: 4, octave: 2, thickness: 6, open_note: \"E2\", label: \"E\" }\n        ]\n    },\n    'guitar_7': {\n        name: '7-String Guitar (BEADGBe)',\n        tuning: [\n            { string: 1, note_index: 4, octave: 4, thickness: 1, open_note: \"E4\", label: \"e\" },\n            { string: 2, note_index: 11, octave: 3, thickness: 2, open_note: \"B3\", label: \"B\" },\n            { string: 3, note_index: 7, octave: 3, thickness: 3, open_note: \"G3\", label: \"G\" },\n            { string: 4, note_index: 2, octave: 3, thickness: 4, open_note: \"D3\", label: \"D\" },\n            { string: 5, note_index: 9, octave: 2, thickness: 5, open_note: \"A2\", label: \"A\" },\n            { string: 6, note_index: 4, octave: 2, thickness: 6, open_note: \"E2\", label: \"E\" },\n            { string: 7, note_index: 11, octave: 1, thickness: 7, open_note: \"B1\", label: \"B\" }\n        ]\n    },\n    'bass_4': {\n        name: '4-String Bass (EADG)',\n        tuning: [\n            { string: 1, note_index: 7, octave: 3, thickness: 4, open_note: \"G3\", label: \"G\" },\n            { string: 2, note_index: 2, octave: 3, thickness: 5, open_note: \"D3\", label: \"D\" },\n            { string: 3, note_index: 9, octave: 2, thickness: 6, open_note: \"A2\", label: \"A\" },\n            { string: 4, note_index: 4, octave: 2, thickness: 7, open_note: \"E2\", label: \"E\" }\n        ]\n    },\n    'bass_5': {\n        name: '5-String Bass (BEADG)',\n        tuning: [\n            { string: 1, note_index: 7, octave: 3, thickness: 3, open_note: \"G3\", label: \"G\" },\n            { string: 2, note_index: 2, octave: 3, thickness: 4, open_note: \"D3\", label: \"D\" },\n            { string: 3, note_index: 9, octave: 2, thickness: 5, open_note: \"A2\", label: \"A\" },\n            { string: 4, note_index: 4, octave: 2, thickness: 6, open_note: \"E2\", label: \"E\" },\n            { string: 5, note_index: 11, octave: 1, thickness: 7, open_note: \"B1\", label: \"B\" }\n        ]\n    },\n    'mandolin': {\n        name: 'Mandolin (GDAE)',\n        tuning: [\n            { string: 1, note_index: 4, octave: 5, thickness: 1, open_note: \"E5\", label: \"E\" },\n            { string: 2, note_index: 9, octave: 4, thickness: 2, open_note: \"A4\", label: \"A\" },\n            { string: 3, note_index: 2, octave: 4, thickness: 3, open_note: \"D4\", label: \"D\" },\n            { string: 4, note_index: 7, octave: 3, thickness: 4, open_note: \"G3\", label: \"G\" }\n        ]\n    },\n    'banjo_5': {\n        name: '5-String Banjo (gDGBd)',\n        tuning: [\n            { string: 5, note_index: 7, octave: 4, thickness: 1, open_note: \"G4\", label: \"g\" }, // Drone string (High G)\n            { string: 1, note_index: 2, octave: 4, thickness: 2, open_note: \"D4\", label: \"d\" },\n            { string: 2, note_index: 11, octave: 3, thickness: 3, open_note: \"B3\", label: \"B\" },\n            { string: 3, note_index: 7, octave: 3, thickness: 4, open_note: \"G3\", label: \"G\" },\n            { string: 4, note_index: 2, octave: 3, thickness: 5, open_note: \"D3\", label: \"D\" }\n        ]\n    }\n};\n\n// Part III: Comprehensive Scale and Mode Library\n// This will be used to populate the UI and query Tonal.js\nexport const SCALES = {\n    'Common': [\n        { name: 'Major', intervals: [0, 2, 4, 5, 7, 9, 11] },\n        { name: 'Natural Minor', intervals: [0, 2, 3, 5, 7, 8, 10] },\n        { name: 'Major Pentatonic', intervals: [0, 2, 4, 7, 9] },\n        { name: 'Minor Pentatonic', intervals: [0, 3, 5, 7, 10] },\n        { name: 'Blues', intervals: [0, 3, 5, 6, 7, 10] }\n    ],\n    'Modes': [\n        { name: 'Ionian (Major)', intervals: [0, 2, 4, 5, 7, 9, 11] },\n        { name: 'Dorian', intervals: [0, 2, 3, 5, 7, 9, 10] },\n        { name: 'Phrygian', intervals: [0, 1, 3, 5, 7, 8, 10] },\n        { name: 'Lydian', intervals: [0, 2, 4, 6, 7, 9, 11] },\n        { name: 'Mixolydian', intervals: [0, 2, 4, 5, 7, 9, 10] },\n        { name: 'Aeolian (Minor)', intervals: [0, 2, 3, 5, 7, 8, 10] },\n        { name: 'Locrian', intervals: [0, 1, 3, 5, 6, 8, 10] }\n    ],\n    'Minor': [\n        { name: 'Harmonic Minor', intervals: [0, 2, 3, 5, 7, 8, 11] },\n        { name: 'Melodic Minor', intervals: [0, 2, 3, 5, 7, 9, 11] }\n    ],\n    'Exotic & Unique': [\n        { name: 'Phrygian Dominant', intervals: [0, 1, 4, 5, 7, 8, 10] },\n        { name: 'Byzantine', intervals: [0, 1, 4, 5, 7, 8, 11] },\n        { name: 'Romanian Minor', intervals: [0, 2, 3, 6, 7, 9, 10] },\n        { name: 'Hungarian Gypsy', intervals: [0, 2, 3, 6, 7, 8, 11] },\n        { name: 'Whole Tone', intervals: [0, 2, 4, 6, 8, 10] },\n        { name: 'Diminished (W-H)', intervals: [0, 2, 3, 5, 6, 8, 9, 11] },\n        { name: 'Diminished (H-W)', intervals: [0, 1, 3, 4, 6, 7, 9, 10] },\n        { name: 'Lydian Augmented', intervals: [0, 2, 4, 6, 8, 9, 11] },\n        { name: 'Altered Scale', intervals: [0, 1, 3, 4, 6, 8, 10] },\n        { name: 'Arabian', intervals: [0, 2, 4, 5, 6, 8, 10] },\n        { name: 'Persian', intervals: [0, 1, 4, 5, 6, 8, 11] },\n        { name: 'Oriental', intervals: [0, 1, 4, 5, 6, 9, 10] },\n        { name: 'Prometheus', intervals: [0, 2, 4, 6, 9, 10] },\n        { name: 'Hiraj?shi', intervals: [0, 2, 3, 7, 8] },\n        { name: 'Neapolitan Major', intervals: [0, 1, 3, 5, 7, 9, 11] }\n    ]\n};\n","size_bytes":5902},"style.css":{"content":"body {\n    font-family: 'Inter', sans-serif;\n    background-color: #f7f7f7;\n    padding: 10px;\n}\n.container {\n    max-width: 100%;\n    margin: auto;\n    padding: 10px;\n}\n.control-group {\n    display: grid;\n    grid-template-columns: repeat(2, 1fr);\n    gap: 10px;\n}\n@media (min-width: 640px) {\n    .control-group {\n        /* Use 4-column layout like the original file for better alignment */\n        grid-template-columns: repeat(4, 1fr);\n    }\n}\nselect, button, input[type=\"number\"] {\n    border-radius: 0.5rem;\n    padding: 8px 12px;\n    font-size: 1rem;\n    border: 1px solid #D1D5DB; /* Added border for inputs */\n}\n\n/* Fretboard GUI Styles from New File */\n.fretboard-container {\n    position: relative;\n    overflow-x: auto; /* Use auto for scrollbars only when needed */\n    margin-top: 15px;\n    margin-bottom: 30px;\n    padding-bottom: 30px; /* Increased padding for numbers */\n    background-color: #5d4037; /* Fretboard wood color (from original file) */\n    border-radius: 8px;\n    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);\n    padding-left: 1rem;\n    padding-right: 1rem;\n}\n.fretboard-gui {\n    position: relative;\n    min-width: 1200px; /* Ensures enough room for 15 frets at 75px spacing */\n    padding-top: 25px; /* Increased vertical padding */\n    padding-bottom: 50px;\n    margin-left: 60px; /* Space for string names */\n}\n.fret {\n    position: absolute;\n    height: 100%;\n    border-left: 2px solid #c0c0c0; /* Fret wire color (from original file) */\n    z-index: 10;\n}\n.string {\n    position: absolute;\n    width: 100%;\n    height: 2px;\n    background-color: #ccc; /* String color (from original file) */\n    z-index: 20;\n}\n.fret-dot {\n    position: absolute;\n    width: 1.5rem; /* 24px (from original file) */\n    height: 1.5rem; /* 24px (from original file) */\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 0.75rem; /* 12px (from original file) */\n    font-weight: bold;\n    color: white;\n    z-index: 30;\n    opacity: 0.9;\n    transition: opacity 0.2s;\n    transform: translate(-50%, -50%); /* Use transform for centering */\n}\n.fret-dot.root {\n    background-color: #e53e3e; /* Root color (from original file) */\n    border: 2px solid #fff;\n    box-shadow: 0 0 5px rgba(229, 62, 62, 0.8);\n}\n.fret-dot.scale {\n    background-color: #3182ce; /* Scale color (from original file) */\n}\n.fret-number {\n    position: absolute;\n    bottom: -25px;\n    left: 0;\n    font-size: 0.9rem; /* Larger fret numbers */\n    color: #ccc;\n    text-align: center;\n    width: 75px; /* Matches FRET_SPACING */\n    transform: translateX(-50%);\n}\n.fret-marker {\n    position: absolute;\n    width: 0.75rem;\n    height: 0.75rem;\n    background-color: #d1d5db;\n    border-radius: 50%;\n    z-index: 15;\n    transform: translate(-50%, -50%); /* Center the marker */\n}\n.string-label {\n    position: absolute;\n    left: -50px;\n    font-size: 0.9rem;\n    color: #ddd;\n    white-space: nowrap;\n    transform: translateY(-50%); /* Vertically center label on string */\n}\n\n/* NEW: Interactive Key & Harmony Section Styles */\n.key-harmony-section {\n    background-color: #f8fafc; /* Lighter gray */\n    border-top: 4px solid #6366f1; /* Indigo */\n}\n.circle-of-fifths {\n    position: relative;\n    width: 300px;\n    height: 300px;\n    margin: 2rem auto;\n}\n.key-button {\n    position: absolute;\n    width: 60px;\n    height: 60px;\n    background-color: #fff;\n    border: 2px solid #d1d5db;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.2s ease-in-out;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.05);\n}\n.key-button:hover {\n    transform: scale(1.1);\n    border-color: #4f46e5;\n    color: #4f46e5;\n}\n.key-button.active {\n    background-color: #4f46e5;\n    color: #fff;\n    border-color: #4f46e5;\n    transform: scale(1.1);\n    box-shadow: 0 0 15px rgba(79, 70, 229, 0.5);\n}\n.diatonic-chord-btn {\n    transition: all 0.2s ease-in-out;\n}\n.diatonic-chord-btn.active {\n    transform: scale(1.05);\n    box-shadow: 0 0 10px rgba(79, 70, 229, 0.4);\n}\n#chord-display-container {\n    min-height: 300px;\n}\n\n/* NEW: Accordion Styles for Fundamentals Library */\n.accordion-header {\n    cursor: pointer;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 0.75rem 1rem;\n    background-color: #f3f4f6;\n    border-radius: 0.5rem;\n    font-weight: 600;\n    color: #4b5563;\n    transition: background-color 0.2s;\n}\n.accordion-header:hover {\n    background-color: #e5e7eb;\n}\n.accordion-content {\n    max-height: 0;\n    overflow: hidden;\n    transition: max-height 0.3s ease-out;\n    background-color: #fafafa;\n    border-radius: 0 0 0.5rem 0.5rem;\n}\n.accordion-content p {\n    padding: 1rem;\n    margin: 0;\n}\n.accordion-symbol {\n    font-weight: bold;\n    transition: transform 0.3s;\n}\n.accordion-header.active .accordion-symbol {\n    transform: rotate(45deg);\n}\n\n\n/* ===== MANUSCRIPT METHOD STYLING (Minimalist Design) ===== */\n\n/* Container */\n.manuscript-container {\n    border: 1px solid #111;\n    padding: 24px;\n    max-width: 960px;\n    margin: 0 auto 48px;\n    background: #fff;\n}\n\n/* Title and Subtitle */\n.manuscript-title {\n    font-size: 24px;\n    font-weight: bold;\n    text-align: center;\n    margin: 0 0 8px 0;\n    color: #111;\n}\n\n.manuscript-subtitle {\n    font-size: 14px;\n    text-align: center;\n    margin: 0 0 20px 0;\n    color: #111;\n}\n\n/* Play Controls */\n.manuscript-controls {\n    display: flex;\n    gap: 12px;\n    justify-content: flex-start;\n    margin-bottom: 24px;\n}\n\n.manuscript-btn {\n    border: 1px solid #111;\n    padding: 8px 16px;\n    background: #fff;\n    font-family: \"Helvetica Neue\", Arial, sans-serif;\n    font-size: 13px;\n    letter-spacing: 0.5px;\n    cursor: pointer;\n    transition: background 0.15s;\n}\n\n.manuscript-btn:hover {\n    background: #f5f5f5;\n}\n\n.manuscript-btn:active {\n    background: #e0e0e0;\n}\n\n/* Phase Sections */\n.manuscript-phase {\n    margin-bottom: 32px;\n}\n\n.phase-title {\n    font-size: 18px;\n    font-weight: 600;\n    text-transform: uppercase;\n    letter-spacing: 1px;\n    margin: 0 0 4px 0;\n    color: #111;\n}\n\n.phase-description {\n    font-size: 13px;\n    margin: 4px 0 12px 0;\n    color: #111;\n}\n\n/* Tab Display Container */\n.tab-display {\n    background: #fff;\n    border: 1px solid #111;\n    padding: 16px 12px;\n    font-family: \"Courier Prime\", \"Courier New\", Consolas, Monaco, monospace;\n    font-size: 14px;\n    line-height: 16px;\n    overflow-x: auto;\n}\n\n/* Tab Staff Lines */\n.tab-staff {\n    font-family: \"Courier Prime\", \"Courier New\", Consolas, Monaco, monospace;\n    font-size: 14px;\n    line-height: 1;\n}\n\n.tab-staff-line {\n    display: flex;\n    align-items: flex-end;\n    gap: 0;\n    min-height: 18px;\n    border-bottom: 1px solid #111;\n}\n\n.tab-staff-line:last-child {\n    border-bottom-width: 2px;\n}\n\n.tab-string-content {\n    display: flex;\n    align-items: flex-end;\n    gap: 0;\n    min-width: max-content;\n}\n\n/* Tab Fret Cells */\n.tab-fret-cell {\n    display: inline-flex;\n    justify-content: center;\n    align-items: flex-end;\n    width: 18px;\n    padding: 0 2px;\n    letter-spacing: 0;\n    line-height: 1;\n}\n\n/* Tab Separators (Measure Bars) */\n.tab-separator {\n    width: 12px;\n    border-left: 1px solid #111;\n    margin: 0 6px;\n    height: 100%;\n}\n\n/* String Labels */\n.tab-staff-line > span:first-child {\n    width: 32px;\n    text-align: left;\n    font-size: 12px;\n    padding-right: 8px;\n    color: #111;\n}","size_bytes":7482},"replit.md":{"content":"# The Fretboard Training Manuscripts\n\nA music theory and fretboard visualization tool for guitarists, bassists, and other stringed instrument players.\n\n## Overview\n\nThis is an interactive web application that helps musicians:\n- Visualize scales and modes on various stringed instruments\n- Learn chord progressions and diatonic harmony\n- Practice with generated tablature sequences\n- Understand music theory fundamentals\n\n**Current State**: Fully functional frontend application built with Vite and vanilla JavaScript. The app uses external CDN libraries for music theory (Tonal.js), audio synthesis (Tone.js), and chord diagrams (SVGuitar).\n\n## Recent Changes (November 13, 2025)\n\n- Imported from GitHub and configured for Replit environment\n- Created Vite configuration for development server on port 5000\n- Added npm scripts for dev, build, and preview\n- Configured deployment settings for production (autoscale)\n- Set up development workflow with webview output\n\n## Project Architecture\n\n### Technology Stack\n- **Build Tool**: Vite 7.2.2\n- **Styling**: Tailwind CSS (CDN), custom CSS\n- **Music Theory**: Tonal.js (CDN)\n- **Audio**: Tone.js (CDN)\n- **Chord Diagrams**: SVGuitar (CDN)\n- **Language**: JavaScript (ES Modules)\n\n### File Structure\n- `index.html` - Main HTML template with controls and layout\n- `main.js` - Core application logic for fretboard visualization and tablature generation\n- `database.js` - Instrument tunings and scale/mode definitions\n- `style.css` - Custom styles and component styling\n- `chord_shapes.json` - Chord fingering data\n- `vite.config.js` - Vite development and build configuration\n- `package.json` - Project dependencies and scripts\n\n### Key Features\n1. **Fretboard Visualization**: Interactive fretboard display showing scale patterns\n2. **Multiple Instruments**: Support for 6/7-string guitars, 4/5-string basses, mandolin, and banjo\n3. **Scale Library**: Common scales, modes, minor scales, and exotic scales\n4. **Interactive Harmony**: Circle of fifths, diatonic chords, and common progressions\n5. **Tablature Training**: Generated tab sequences with customizable tempo and formatting\n6. **Educational Content**: Built-in music theory fundamentals with accordion panels\n\n## Development\n\n### Running Locally\n```bash\nnpm install\nnpm run dev\n```\nThe app will run on http://0.0.0.0:5000\n\n### Building for Production\n```bash\nnpm run build\nnpm run preview\n```\n\n## Configuration Notes\n\n- **Port**: Development server runs on port 5000 (required for Replit webview)\n- **Host**: Configured to bind to 0.0.0.0 for external access\n- **HMR**: Hot Module Replacement configured for port 5000\n- **Deployment**: Uses autoscale deployment target with Vite preview server\n","size_bytes":2698},"vite.config.js":{"content":"import { defineConfig } from 'vite'\n\nexport default defineConfig({\n  server: {\n    host: '0.0.0.0',\n    port: 5000,\n    strictPort: true,\n    hmr: {\n      clientPort: 5000\n    },\n    allowedHosts: true\n  },\n  preview: {\n    host: '0.0.0.0',\n    port: 5000,\n    strictPort: true,\n    allowedHosts: true\n  }\n})\n","size_bytes":309}},"version":2}